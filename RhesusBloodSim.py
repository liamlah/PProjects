#Rhesus population calculator python 3.10.4
#Created by Liam Jones

#todo list:
	#start using f-strings
	#clean up arguments in functions
	#replace lists with arrays where possible then clean up
	#work on GUI branch


import random
from random import choice
import matplotlib.pyplot as plt
import numpy as np
from os import system, name
#function from g4g to clear screen output while calculating generations
def clear():
    # for windows
    if name == 'nt':
        _ = system('cls')
 
    # for mac and linux(here, os.name is 'posix')
    else:
        _ = system('clear')

nextgenalleles = []
thisgenalleles = []
obituaries = []
frequencylistP = []
frequencylistN = []
generationgraph = []
generationpopulationcount= []

#Starting function. This takes the input that will seed the rest of the program, then passes it to runsim function
print("This program will simulate the propagation of Rhesus negative alleles through a population\n")
def startchoices():
	infochoice = str(input("Would you like some theory behind the model? Y for yes, or any key to skip\n>>>"))
	infochoice = infochoice.lower()
	if infochoice.lower() == 'y':
		print("The Rhesus blood groups are the negative and positive groups, these are separate to to A/B/O group. The Rhesus (D) positive is the default and the negative is a mutation caused by a deletion of the gene. The Rhesus gene is dominant, meaning that you only need one positive of two alleles to express the rhesus (D) surface molecule on your red blood cells. The genes are clinically signficant because if an expectant mother is homozygous negative, i.e. she has inherited negative alleles from both parents, but her foetus has inherited a positive allele from the father, then her immune system can develop antibodies to the foetal blood. This is rarely an issue in the first pregnancy, but often during labour, or a miscarriage, maternal and foetal blood mixed, sensitising the mother to rhesus positive foetal blood. During subsequent pregnancies where the foetus is heterozygous, the antibodies produced by the mother can cross the placenta and attack the foetal red blood cells, causing a condition called Haemolytic Disease of the Foetus and Neonate(HDFN). Without a blood transfusion, the condition is fatal. However in recent decades, prophylactic antibodies are given to pregnant women who are rhesus negative, to prevent sensitisation to the foetal rhesus antigens.\n\nThis program will generate hypothetical couples with a selected distribution of alleles, and offspring generated by these couples will inherit the parental genes at random. If a foetus' blood group is incompatible with the mother as described above, the child will not survive to the next generation. The simulation will run for the selected number of generations before presenting a visualisation of the allele frequencies through each generation.\n")
	startprevalence = 0
	while True:
		try:
			startprevalence = int(input("What percentage of the population Rhesus positive do you want to start with.\n>>>"))
			if 1 < startprevalence < 100:
				break
			raise ValueError()
		except ValueError:
			print("***Please choose a number between 1 and 100***")
	while True:
		try:
			startpopulationsize = int(input("How many couples are in your starting population? Hint:~1000 is a good number\n>>>"))
			if 0 < startpopulationsize < 10001:
				break
			raise ValueError()
		except ValueError:
			print("***Please Choose a number. Remember, A population below zero isn't going to work, and above 10000 is going to take too long, try again***")
	while True:
		try:
			generationtime = int(input("How many generations do you want to simulate? Enter 1000 to run until an allele reaches a frequency of 100%\n>>>"))
			if 1 < generationtime < 1001:
				break
			raise ValueError()
		except ValueError:
			print("***Please choose a number between 1 and 1001***")
	while True:
		try:
			averagefamilysize = int(input("What is the average family size? family sizes will be randomly generated with a gaussian distribution. A reasonable average is below 10\n>>>"))
			if 0 < averagefamilysize < 50:
				break
			raise ValueError()
		except ValueError:
			print("***Please choose a number between 1 and 50***")
	frequencylistP.append(startprevalence/100)
	generationpopulationcount = startpopulationsize
	runsim(startprevalence,startpopulationsize,generationtime,averagefamilysize,frequencylistP,frequencylistN,generationgraph)	


#Takes the input from startchoices, creates classes for the hypothetical couples and represents the alleles as (x,x).
#A random number is generated between 1 and 100, and the frequency percent you choose in the first function determines the cutoff.
#If a randomly generated number is below your chosen frequency, then the allele is positive
#The for loop iterates this process for each couple in the starting population, and for each couple, their data is sent to the generations function.
def runsim(startprevalence,startpopulationsize,generationtime,averagefamilysize,frequencylistP,frequencylistN,generationgraph):
	class father: #sets the attributes of the father
		allele1 = 0
		allele2 = 0
		phenotype = (allele1, allele2)
	class mother: #sets mother attributes
		allele1 = 0
		allele2 = 0
		phenotype = (allele1, allele2)
		sensitised = 0
	class child: #sets child attributes, which will be inherited randomly from father and mother
		allele1 = 0
		allele2 = 0
		phenotype = (allele1, allele2)
	for x in range (0, startpopulationsize):
		positivechance = random.randint(0,100)
		if positivechance <= startprevalence:
				father.allele1 = 1
		else:
				father.allele1 = 0
		positivechance = random.randint(0,100)
		if positivechance <= startprevalence:
				father.allele2 = 1
		else:
				father.allele2 = 0
		father.phenotype = (father.allele1, father.allele2)
		positivechance = random.randint(0,100)
		if positivechance <= startprevalence:
				mother.allele1 = 1
		else:
				mother.allele1 = 0
		positivechance = random.randint(0,100)
		if positivechance <= startprevalence:
				mother.allele2 =1
		else:
				mother.allele2 = 0		
		mother.phenotype = (mother.allele1, mother.allele2)
		conception(averagefamilysize,child,father,mother,generationtime,obituaries,generationpopulationcount,frequencylistP,frequencylistN,generationgraph)
	if thisgenalleles == []:
		generations(generationtime,thisgenalleles,nextgenalleles,father,mother,averagefamilysize,child,obituaries,frequencylistP,frequencylistN,generationgraph)
	else:
		pass #this is important, and I can't explain why



#This function first generates a family size around a gaussian distribution, so not every family is exactly the same size. But all families are guaranteed to conceive at least one child.
#This function does not pass to another function, once it has finished iterating, the program will move back up to the generations function to complete the for loop and pass to the endresults function. 
def conception(averagefamilysize,child,father,mother,generationtime,obituaries,generationpopulationcount,frequencylistP,frequencylistN,generationgraph):
	#print("new family")
	familydistribution = random.gauss(averagefamilysize, averagefamilysize/4)
	if familydistribution < 1:
		familydistribution = 1
	familydistribution = round(familydistribution)
	#The for loop iterates for each child conceived. 1 or 0 is picked at random, and this determines whether the first or second allele is passed from the parent to child. Simulating the randomness of meiosis
	#child.phenotype then reformats these two number into the same tuple (x,x) as a parent
	mothersensitised = 0 #each mother starts off unsensitised, and rh- mothers can become sensitised. Sensitising child survives, but subsequent mismatches die
	for y in range (0, familydistribution):
		zygosity = random.randint(0,1)
		if  zygosity == 1:
			child.allele1 = father.allele1
		else:
			child.allele1 = father.allele2
		zygosity = random.randint(0,1)
		if zygosity == 1:
			child.allele2 = mother.allele1
		else:
			child.allele2 = mother.allele2
		child.phenotype = (child.allele1, child.allele2) 
		#Each rh- mother is sensitised in a way that correctly models the real world
		#If the child and mother are incompatible, the child is added to the obituaries list, if not, the child is added to the next generation list.
		if mother.phenotype == (0,0) and child.phenotype !=(0,0)  and mothersensitised == 1: #mother.sensitised >0: 
			obituaries.append(1)
			#print(len(obituaries), "this is an obituary")
		elif mother.phenotype == (0,0) and child.phenotype !=(0,0)  and mothersensitised == 0:
			#print("mother just got sensitised")
			mothersensitised = 1
			nextgenalleles.append(child.phenotype)
		else:
			nextgenalleles.append(child.phenotype)
			#print("mother had child without incident")
	storecountpositivehetero =+ nextgenalleles.count((1 , 0)) + nextgenalleles.count((0 , 1))
	storecountnegativehomo=+ nextgenalleles.count((0 , 0))
	storecountpositivehomo =+ nextgenalleles.count((1 , 1))

		

#Takes the data initially from runsim and the first for loop keeps a log of the number of generations that have passed and the distribution of alleles in each generation. 
def generations(generationtime,thisgenalleles,nextgenalleles,father,mother,averagefamilysize,child,obituaries,frequencylistP,frequencylistN,generationgraph):
	obituarycounter = []
	for x in range(0, generationtime):
		if generationgraph !=[]:
			clear()
			print("calculating generation:",generationgraph[-1]+1)
		generationgraph.append(x)
		generationalobituary = len(obituaries)
		obituarycounter.append(generationalobituary)
		#print(obituarycounter) if you wish to debug
		obituaries.clear()
		generationalobituary = 0
		hozp =nextgenalleles.count((1, 1))
		hetz1 = nextgenalleles.count((1, 0))
		hetz2 = nextgenalleles.count((0, 1))
		hozn = nextgenalleles.count((0, 0))
		if len(nextgenalleles) > len(thisgenalleles):
			totalpos = ((hozp+0.5*hetz1+ 0.5*hetz2)/len(nextgenalleles)) #calculates the total positive by counting all the homozygous positives, then weighting the heterozygotes by half, then dividing by the length of the list of alleles
			totalpos2 = 1-totalpos
			generationpopulationcount.append(len(nextgenalleles))
		elif len(nextgenalleles) <= len(thisgenalleles):
			totalpos = ((hozp+0.5*hetz1+ 0.5*hetz2)/len(thisgenalleles))
			totalpos2 = 1-totalpos
			generationpopulationcount.append(len(thisgenalleles))
		frequencylistP.append(totalpos)
		if nextgenalleles and all(elem == (1, 1) for elem in nextgenalleles):
			endresults(generationgraph,totalpos,totalpos2,frequencylistP,frequencylistN,obituarycounter,generationtime,nextgenalleles,obituaries)
		elif nextgenalleles and all(elem ==(0,0) for elem in nextgenalleles):
			endresults(generationgraph,totalpos,totalpos2,frequencylistP,frequencylistN,obituarycounter,generationtime,nextgenalleles,obituaries)
		else:obituaries.clear()

		#This neatly takes the data we got from the childrens genes, then moves them to the adult list so they can be used to create the next generation
		thisgenalleles.clear()
		random.shuffle(nextgenalleles)
		if len(nextgenalleles) > 1000:
			listmaxcalc = (1000 - len(nextgenalleles))
			thisgenalleles = nextgenalleles[:len(nextgenalleles)+listmaxcalc]
		else:
			thisgenalleles.extend(nextgenalleles)	
		nextgenalleles.clear()
		#The second for loop replaces the runsim algorithm for the subsequent generations. This is because we no longer need to generate couples based on probability, instead subsequent generations inherit the genes from the previous.
		#Each existing person from the current generation exists as a discrete set of two alleles in a list. A random number generator called the 'matchmaker' picks the father, removes him from the list
		#Then a new number is generated, which picks the mother and removes her from the list. In both cases, their genes are transferred to their respective classes.
		#each time this iterates, the parents attributes are passed to the conception function to generate their children.
		#The for loop runs for the length of the list of this generations alleles, when that runs out, the data is passed to the endresults function
		for x in range(0, len(thisgenalleles)):
			while len(thisgenalleles)-1 >2:	
				matchmaker = random.randint(0 , len(thisgenalleles) -1)
				father.phenotype = thisgenalleles[matchmaker]
				father.allele1 = father.phenotype[0]
				father.allele2 = father.phenotype[1]
				thisgenalleles.pop(matchmaker)
				matchmaker = random.randint(0 , len(thisgenalleles) -1)
				mother.phenotype = thisgenalleles[matchmaker]
				mother.allele1 = mother.phenotype[0]
				mother.allele2 = mother.phenotype[1]
				thisgenalleles.pop(matchmaker)
				conception(averagefamilysize,child,father,mother,generationtime,obituaries,generationpopulationcount,frequencylistP,frequencylistN,generationgraph)
	endresults(generationgraph,totalpos,totalpos2,frequencylistP,frequencylistN,obituarycounter,generationtime,nextgenalleles,obituaries)


#The final function
#takes the frequency lists recorded previously and plots them on a chart
#this can also be used to present in numerical terms the various statistics, as it does not iterate, and will only print once.
def endresults(generationgraph,totalpos,totalpos2,frequencylistP,frequencylistN,obituarycounter,generationtime,nextgenalleles,obituaries):
	generationgraph.append(generationgraph[-1]+1)
	if len(nextgenalleles) > len(thisgenalleles):
		generationpopulationcount.append(len(nextgenalleles))
	elif len(nextgenalleles) <= len(thisgenalleles):
		generationpopulationcount.append(len(thisgenalleles))
	print("this is length of genpop", len(generationpopulationcount))
	print("this is genpop",generationpopulationcount)
	print("the end proportion of positive alleles is", totalpos)
	print("the end proportion of negative alleles is", 1-totalpos) #gets the inverse of the positive alleles for the output
	frequencylistN = [1-x for x in frequencylistP]
	print("Generations:",generationgraph)
	FlistPRound = [round(num, 3) for num in frequencylistP]
	FlistNRound = [round(num, 3) for num in frequencylistN]
	print("Positive frequencies per generation", FlistPRound)
	print("Negative frequencies per generation", FlistNRound)
	generationalobituary = len(obituaries)
	obituarycounter.append(generationalobituary)
	print(obituarycounter,"this is obitcount")
	#begin settings for graph creation
	fig, ax1 = plt.subplots(num='Rhesus Allele Results')
	#fig.suptitle('Modelled frequency of rhesus alleles in a population for which haemolytic disease of the foetus and newborn(HDFN) is untreated.', wrap=True)
	plt.title('Modelled frequency of rhesus alleles in a population for which haemolytic disease of the foetus and newborn(HDFN) is untreated.', wrap=True)
	ax1.plot(generationgraph, frequencylistP, color='red', linestyle = 'None',  marker='D', label ='Rh+')
	ax1.plot(generationgraph, frequencylistN, color='black', linestyle = 'None', marker='o', label ='Rh-') 
	ax1.set_xlim(auto=True)
	
	#setting details for allele frequency part
	ax1.set_xlabel('Generation number')
	ax1.set_ylabel('Allele frequency')
	ax1.set_ylim(0.0, 1.1,)
	ax1.set_yticks(np.arange(0.0, 1.1, 0.1))  # Assuming you have 'import numpy as np'

	ax1.grid(True)
	plt.legend(loc='upper left')
	#converting list to array - Replacing all lists with arrays from the start is on todo list
	obituarycounterarray = np.array(obituarycounter)
	generationpopulationcountarray = np.array(generationpopulationcount)
	totalpopulation = obituarycounterarray + generationpopulationcountarray
	obitpercent = (obituarycounterarray/totalpopulation)*100 
	#setting details to show how many deaths are occurring in a generation from HDFN
	ax2 = ax1.twinx()
	ax2.bar(generationgraph, obitpercent, width=0.5, alpha=0.5, color='darkorange', label ='HDFN(right)')
	ax2.set_ylabel('%'' of deaths per generation due to HDFN', color ='darkorange')
	ax2.set_ylim(0, max(obitpercent))
	ax2.set_ylim(0,100)
	plt.legend(loc='upper right')
	plt.show()
	
	exit()
	

startchoices()
